<?xml version="1.0" encoding="utf-8"?>

<!---

Test class. Instruments a demo integration of the `Nodal.mxml` and
`SelectionPanel.mxml` components. Also uses own UI to access/consume
the API `Nodal.mxml` provides.

N.B.: this is NOT production code. Don't just copy this over in your
project mindlessly. Treat all of the below as an example.

-->

<s:WindowedApplication
	xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	xmlns:flexnodal="com.github.ciacob.flexnodal.*"
	xmlns:components="com.github.ciacob.flexnodal.components.*"
	preinitialize="_onPreinitialize()">

	<fx:Declarations>

		<!-- Tab data provider -->
		<s:ArrayCollection id="chartModes">
			<fx:Object label="Readonly" data="{Nodal.READONLY}"/>
			<fx:Object label="Normal" data="{Nodal.NORMAL}"/>
			<fx:Object label="Exclusive" data="{Nodal.EXCLUSIVE}"/>
			<fx:Object label="Isolated" data="{Nodal.ISOLATED}"/>
		</s:ArrayCollection>
	</fx:Declarations>

	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		global {
			font-size: 15;
		}

		s|WindowedApplication {
			chromeColor: #444444;
			backgroundColor: #444444;
			color: #ffffff;
		}

		s|NumericStepper,
		s|ComboBox {
			borderColor: #000000;
			contentBackgroundColor: #141414;
		}

		s|NumericStepper  {
			paddingLeft: 5;
		}

		s|List {
			contentBackgroundColor: #303030;
			alternatingItemColors: #303030;
			rollOverColor: #2a57dd; 
			selectionColor: #007994;
		}

		.myChartStyle {
			padding: 15;

			lineThickness: 4;
			lineColor: #3c0097;
			lineColorOver: #6637ad;
			lineColorSelected: #934bff;
			lineColorAnchor: #301b4f;
			defaultAlpha : 0.5;

			layerColor: #9794a1;
			chartBg: #f6e2f9;
			chartBgAlpha: 1;

			xAxisColor: #3a0256;
			yAxisColor: #003e6e;
			xAxisAlpha: 1;
			yAxisAlpha: 1;
		}

		.selectionPanelStyle {
			verticalGap: 10;
			horizontalGap: 10;
			padding: 5;
			rowHeight: 25;
			minHeight: 105;
			headerStyle: mySelHeaderStyle;
			bodyStyle: mySelBodyStyle;
			buttonStyle: mySelButtonStyle;
		}

		.mySelHeaderStyle {
			color: #bfabca;
		}

		.mySelBodyStyle {
			color: #e4e4e4;
		}

		.mySelButtonStyle {
			color: #c6c6c6;
		}
	</fx:Style>

	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import spark.events.IndexChangeEvent;
			import com.github.ciacob.flexnodal.events.NodalEvent;
			import com.github.ciacob.flexnodal.Nodal;
			
			// Flags to raise when the active chart has selection.
			[Bindable]
			private var _haveSelection:Boolean;
			
			// Sample charts to edit. Other can be added via test buttons.
			[Bindable]
			private var dp:ArrayCollection = new ArrayCollection([
						{
							name: "Blue",
							values: [[0, 0.1], [0.5, 0.8], [0.95, 0], [1, 0]],
							dashStyle: [10, 15]
						},
						{
							name: "Red",
							values: [[0, 0], [1, 1]],
							dashStyle: [1, 10],
							hueFactor: 0.3
						},
						{
							name: "Green",
							values: [[0, 1], [1, 0]],
							hueFactor: 0.6
						}
					]);
			
			// Grid cells to display underneath the charts.
			private const gridDp:ArrayCollection = new ArrayCollection([
						{axis: 'x', stop: 0.1, label: '10'},
						{axis: 'x', stop: 0.2, label: '20'},
						{axis: 'x', stop: 0.3, label: '30'},
						{axis: 'x', stop: 0.4, label: '40'},
						{axis: 'x', stop: 0.5, label: '50'},
						{axis: 'x', stop: 0.6, label: '60'},
						{axis: 'x', stop: 0.7, label: '70'},
						{axis: 'x', stop: 0.8, label: '80'},
						{axis: 'x', stop: 0.9, label: '90'},
						{axis: 'y', stop: 0.1, label: '10'},
						{axis: 'y', stop: 0.2, label: '20'},
						{axis: 'y', stop: 0.3, label: '30'},
						{axis: 'y', stop: 0.4, label: '40'},
						{axis: 'y', stop: 0.5, label: '50'},
						{axis: 'y', stop: 0.6, label: '60'},
						{axis: 'y', stop: 0.7, label: '70'},
						{axis: 'y', stop: 0.8, label: '80'},
						{axis: 'y', stop: 0.9, label: '90'},
					]);
			
			/**
			 * Un-selects the active chart's selection.
			 */
			private function _clearSelection():void {
				if (!_haveSelection) {
					return;
				}
				nodalEditor.clearSelection();
			}
			
			/**
			 * Deletes the active chart's selected nodes.
			 */
			private function _deleteSelection():void {
				if (!_haveSelection) {
					return;
				}
				nodalEditor.deleteSelection();
			}
			
			/**
			 * Listener. Executes at the beginning of the component initialization sequence.
			 */
			private function _onPreinitialize():void {
				// TEST: disable active chart shadow
				// Nodal.ACTIVE_CHART_SHADOW = null;
			}
			
			/**
			 * Listener. Executes when the "charts list" test combo box is changed.
			 */
			private function _onActiveChartChanged(event:IndexChangeEvent):void {
				if (!event || event.newIndex < 0 || event.newIndex > dp.length) {
					return;
				}
				const dpItem:Object = dp.getItemAt(event.newIndex);
				nodalEditor.activeChartItem = dpItem;
			}
			
			/**
			 * Listener. Executes when user clicks on one of the test "Operation mode" tabs.
			 */
			private function _onModeChanged(event:IndexChangeEvent):void {
				if (!event || event.newIndex < 0 || event.newIndex > chartModes.length) {
					return;
				}
				nodalEditor.operatingMode = chartModes[event.newIndex].data;
			}
			
			/**
			 * Listener. Executes after user has activates a specific chart by clicking
			 * on its line. Updates the `SelectionPanel` instance and our own test UI.
			 */
			private function _onChartActivated(event:NodalEvent):void {
				const chartDp:Object = event.payload;
				chartsList.selectedItem = chartDp;
			
				if (chartDp && selectionPanel) {
					selectionPanel.chartName = chartDp.name || '';
				}
			}
			
			/**
			 * Listener. Executes after user has changed the values of the active chart by
			 * adding, deleting or moving nodes.
			 */
			private function _onChartDataChanged(event:NodalEvent):void {
			
				// Just prints out the new values.
				trace(event, JSON.stringify(event.payload));
			}
			
			/**
			 * Listener. Executes after user has caused the selection of the active chart to
			 * change. Updates the `SelectionPanel` instance.
			 */
			private function _onSelectionChanged(event:NodalEvent):void {
				if (!event) {
					return;
				}
				selectionPanel.dataProvider = event.payload;
				_haveSelection = event.payload && event.payload.selectedNode;
			}
			
			/**
			 * Listener. Executes after user has modified the value of one or more selected nodes
			 * by means of the `SelectionPanel` instance.
			 */
			private function _onSelectionPatch(event:NodalEvent):void {
				if (!event || !event.payload) {
					return;
				}
				nodalEditor.patchSelection(event.payload);
			}
			
			// [STRESS_TESTING]
			private var _numTests:int = 0;
			
			private var _testCharts:Array = [];
			
			private function _randomUnit():Number {
				// Generate a random number in [0,1], inclusive of both ends
				// Multiply by 10000 (or any precision scale), round, then divide back.
				return Math.round(Math.random() * 10000) / 10000;
			}
			
			private function _addRandomChart():int {
				if (!dp) {
					_setEmptyDataProvider();
				}
				var count:int = Math.floor(Math.random() * 21); // 0..20
				var values:Array = [];
				for (var i:int = 0; i < count; i++) {
					var x:Number = _randomUnit();
					var y:Number = _randomUnit();
					values.push([x, y]);
				}
			
				values.sort(function(a:Array, b:Array):int {
						return a[0] < b[0] ? -1 : (a[0] > b[0] ? 1 : 0);
					});
			
				var item:Object = {
						name: "Random Item " + (++_numTests),
						values: values
					};
				if (Math.random() < 0.5) {
					var dash:int = Math.max(1, Math.round(Math.random() * 20));
					var gap:int = Math.max(1, Math.round(Math.random() * 20));
					item.dashStyle = [dash, gap];
				}
			
				var index:int = Math.floor(Math.random() * (dp.length + 1));
				dp.addItemAt(item, index);
				return index;
			}
			
			private function _addEmptyChart():void {
				if (!dp) {
					_setEmptyDataProvider();
				}
				var index:int = Math.floor(Math.random() * (dp.length + 1));
				var emptyChart:Object = {
						name: "Random Item " + (++_numTests),
						values: []
					};
				dp.addItemAt(emptyChart, index);
				_testCharts.push(emptyChart);
			}
			
			private function _addTestChart():void {
				if (!dp) {
					return;
				}
				const idx:int = _addRandomChart();
				const testChart:Object = dp.getItemAt(idx);
				trace('`__addTestChart()` called. Added (index, item):', idx, JSON.stringify(testChart));
				_testCharts.push(testChart);
			}
			
			private function _removeLastTestChart():void {
				if (!dp) {
					return;
				}
				if (!_testCharts.length) {
					return;
				}
				const toRemove:Object = _testCharts.pop();
				var removed:Boolean;
				if (toRemove === null) {
					removed = dp.removeItemAt(dp.getItemIndex(null));
				}
				else {
					removed = dp.removeItem(toRemove);
				}
				trace('`_removeRandomItem()` called. Removed: ', removed ? JSON.stringify(toRemove) : 'NULL');
			}
			
			private function _setNullDataProvider():void {
				dp = null;
			}
			
			private function _setEmptyDataProvider():void {
				dp = new ArrayCollection;
			}
			
			private function _setNullItem():void {
				if (!dp) {
					_setEmptyDataProvider();
				}
				var index:int = Math.floor(Math.random() * (dp.length + 1));
				dp.addItemAt(null, index);
				_testCharts.push(null);
			}
		]]>
	</fx:Script>

	<s:VGroup padding="25" width="100%" height="100%"
		horizontalAlign="justify">

		<!-- Controls bar -->
		<s:HGroup id="controls">

			<!-- List of available charts. Sets and reflects the active chart. -->
			<s:Group width="100%">
				<s:ComboBox
					id="chartsList"
					dataProvider="{dp}" labelField="name"
					change="{_onActiveChartChanged(event)}"/>
			</s:Group>

			<!-- Selection-related UI -->
			<s:HGroup horizontalAlign="center" width="100%">
				<s:Button label="Clear selection"
					enabled="{_haveSelection}"
					click="{_clearSelection()}"/>

				<s:Button label="Delete selection"
					enabled="{_haveSelection}"
					click="{_deleteSelection()}"/>
			</s:HGroup>

			<!-- Editing mode for current chart -->
			<s:Group width="100%">
				<s:ButtonBar id="modeButtons"
					selectedIndex="1"
					dataProvider="{chartModes}"
					change="_onModeChanged(event)"
					right="0"/>
			</s:Group>

		</s:HGroup>

		<!-- Nodal component (the actual charts editor) -->
		<flexnodal:Nodal
			id="nodalEditor"
			height="100%"
			dataProvider="{dp}"
			gridDataProvider="{gridDp}"
			chartStyle="myChartStyle"
			selectionChange="_onSelectionChanged (event)"
			chartDataChange="_onChartDataChanged (event)"
			chartActivation="_onChartActivated (event)"/>

		<!-- Selection panel, for monitoring and adjusting selected nodes' value -->
		<s:VGroup horizontalAlign="center">
			<components:SelectionPanel
				id="selectionPanel"
				styleName="selectionPanelStyle"
				selectionPatch="_onSelectionPatch (event)"/>
		</s:VGroup>

		<!-- Various buttons for stress-testing -->
		<s:TileGroup horizontalAlign="justify"
			columnAlign="justifyUsingWidth"
			rowAlign="justifyUsingHeight"
			verticalGap="20" horizontalGap="20"
			requestedRowCount="2"
			rowHeight="22">

			<s:Button label="Add test chart" click="_addTestChart()"/>
			<s:Button label="Add empty chart" click="_addEmptyChart()"/>
			<s:Button label="Remove last test chart" click="_removeLastTestChart()"/>
			<s:Button label="Set NULL data provider" click="_setNullDataProvider()"/>
			<s:Button label="Set NULL item" click="_setNullItem()"/>
			<s:Button label="Set empty data provider" click="_setEmptyDataProvider()"/>
		</s:TileGroup>

	</s:VGroup>
</s:WindowedApplication>
