<?xml version="1.0" encoding="utf-8"?>

<!---

Test class. Instruments a demo integration of the `Nodal.mxml` and
`SelectionPanel.mxml` components. Also uses own UI to access/consume
the API `Nodal.mxml` provides.

N.B.: this is NOT production code. Don't just copy this over in your
project mindlessly. Treat all of the below as an example.

-->

<s:WindowedApplication
	xmlns:fx="http://ns.adobe.com/mxml/2009"
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	xmlns:flexnodal="com.github.ciacob.flexnodal.*"
	xmlns:components="com.github.ciacob.flexnodal.components.*"
	preinitialize="_onPreinitialize()">

	<fx:Declarations>

		<!-- Tab data provider -->
		<s:ArrayCollection id="chartModes">
			<fx:Object label="Readonly" data="{Nodal.READONLY}"/>
			<fx:Object label="Normal" data="{Nodal.NORMAL}"/>
			<fx:Object label="Exclusive" data="{Nodal.EXCLUSIVE}"/>
			<fx:Object label="Isolated" data="{Nodal.ISOLATED}"/>
		</s:ArrayCollection>
	</fx:Declarations>

	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		global {
			font-size: 15;
		}

		s|WindowedApplication {
			chromeColor: #444444;
			backgroundColor: #444444;
			color: #ffffff;
		}

		s|NumericStepper,
		s|ComboBox {
			borderColor: #000000;
			contentBackgroundColor: #141414;
		}

		s|NumericStepper  {
			paddingLeft: 5;
		}

		s|List {
			contentBackgroundColor: #303030;
			alternatingItemColors: #303030;
			rollOverColor: #2a57dd; 
			selectionColor: #007994;
		}

		.myChartStyle {
			padding: 15;

			lineThickness: 4;
			lineColor: #3c0097;
			lineColorOver: #6637ad;
			lineColorSelected: #934bff;
			lineColorAnchor: #301b4f;
			defaultAlpha : 0.5;

			layerColor: #9794a1;
			chartBg: #f6e2f9;
			chartBgAlpha: 1;

			xAxisColor: #3a0256;
			yAxisColor: #003e6e;
			xAxisAlpha: 1;
			yAxisAlpha: 1;
		}

		.selectionPanelStyle {
			verticalGap: 10;
			horizontalGap: 10;
			padding: 5;
			rowHeight: 25;
			minHeight: 105;
			headerStyle: mySelHeaderStyle;
			bodyStyle: mySelBodyStyle;
			buttonStyle: mySelButtonStyle;
		}

		.mySelHeaderStyle {
			color: #bfabca;
		}

		.mySelBodyStyle {
			color: #e4e4e4;
		}

		.mySelButtonStyle {
			color: #c6c6c6;
		}
	</fx:Style>

	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import spark.events.IndexChangeEvent;
			import com.github.ciacob.flexnodal.events.NodalEvent;
			import com.github.ciacob.flexnodal.Nodal;
			import com.github.ciacob.flexnodal.utils.ChartDescriptor;
			import com.github.ciacob.flexnodal.utils.Helpers;
			import flash.geom.Point;
			import mx.collections.ArrayCollection;
			import com.github.ciacob.flexnodal.events.ChartEditEvent;
			import com.github.ciacob.flexnodal.utils.ChartEdit;
			import com.github.ciacob.flexnodal.events.SelectionEvent;
			import com.github.ciacob.flexnodal.utils.SelectionDetails;
			
			// Flags to raise when the active chart has selection.
			[Bindable]
			private var _haveSelection:Boolean;
			
			// Sample charts to edit. Other can be added via test buttons.
			[Bindable]
			private var dp:Vector.<ChartDescriptor> = new <ChartDescriptor>[
					new ChartDescriptor(
						Helpers.makeUuid(),
						new <Point>[
							new Point(0, 0.1),
							new Point(0.5, 0.8),
							new Point(0.95, 0),
							new Point(1, 0),
						],
						"Blue",
						0,
						new <Number>[10, 15]
					),
					new ChartDescriptor(
						Helpers.makeUuid(),
						new <Point>[
							new Point(0, 0),
							new Point(1, 1)
						],
						"Red",
						0.3,
						new <Number>[1, 10]
					),
					new ChartDescriptor(
						Helpers.makeUuid(),
						new <Point>[
							new Point(0, 1),
							new Point(1, 0),
						],
						"Green",
						0.6
					)
				];
			
			// Storage for the data provider of the "Active Chart" drop down.
			[Bindable]
			private var _chartsListDp:ArrayCollection;
			
			// Grid cells to display underneath the charts.
			private const gridDp:ArrayCollection = new ArrayCollection([
						{axis: 'x', stop: 0.1, label: '10'},
						{axis: 'x', stop: 0.2, label: '20'},
						{axis: 'x', stop: 0.3, label: '30'},
						{axis: 'x', stop: 0.4, label: '40'},
						{axis: 'x', stop: 0.5, label: '50'},
						{axis: 'x', stop: 0.6, label: '60'},
						{axis: 'x', stop: 0.7, label: '70'},
						{axis: 'x', stop: 0.8, label: '80'},
						{axis: 'x', stop: 0.9, label: '90'},
						{axis: 'y', stop: 0.1, label: '10'},
						{axis: 'y', stop: 0.2, label: '20'},
						{axis: 'y', stop: 0.3, label: '30'},
						{axis: 'y', stop: 0.4, label: '40'},
						{axis: 'y', stop: 0.5, label: '50'},
						{axis: 'y', stop: 0.6, label: '60'},
						{axis: 'y', stop: 0.7, label: '70'},
						{axis: 'y', stop: 0.8, label: '80'},
						{axis: 'y', stop: 0.9, label: '90'},
					]);
			
			/**
			 * Un-selects the active chart's selection.
			 */
			private function _clearSelection():void {
				if (!_haveSelection) {
					return;
				}
				nodalEditor.clearSelection();
			}
			
			/**
			 * Deletes the active chart's selected nodes.
			 */
			private function _deleteSelection():void {
				if (!_haveSelection) {
					return;
				}
				nodalEditor.deleteSelection();
			}
			
			/**
			 * Listener. Executes at the beginning of the component initialization sequence.
			 */
			private function _onPreinitialize():void {
				// Build the data provider for the "Active Chart" drop down.
				_chartsListDp = new ArrayCollection;
				for (var i:int = 0; i < dp.length; i++) {
					const desc:ChartDescriptor = dp[i];
					_chartsListDp.addItem({label: desc.name, uid: desc.uid});
				}
			}
			
			/**
			 * Listener. Executes when the "charts list" test combo box is changed.
			 */
			private function _onActiveChartChanged():void {
				if (!chartsList) {
					return;
				}
			
				const selectedItem:Object = chartsList.selectedItem;
				if (!selectedItem) {
					return;
				}
			
				nodalEditor.activeChartId = selectedItem.uid;
			}
			
			/**
			 * Listener. Executes when user clicks on one of the test "Operation mode" tabs.
			 */
			private function _onModeChanged(event:IndexChangeEvent):void {
				if (!event || event.newIndex < 0 || event.newIndex > chartModes.length) {
					return;
				}
				nodalEditor.operatingMode = chartModes[event.newIndex].data;
			}
			
			/**
			 * Listener. Executes after user has activates a specific chart by clicking
			 * on its line. Updates the `SelectionPanel` instance and our own test UI.
			 */
			private function _onChartActivated(event:NodalEvent):void {
				if (!event || !event.uid) {
					return;
				}
				const chartUid:String = event.uid;
			
				// Filtering utility
				const filterFn:Function = function(item:Object, ...ignore):Boolean {
					return item && item.uid === chartUid;
				};
			
				// Update the "Active Chart" drop down.
				const itemToSelect:Object = _chartsListDp.source.filter(filterFn)[0];
				chartsList.selectedItem = itemToSelect;
			
				// Update side information inside the `SelectionPanel` instance.
				const chart:ChartDescriptor = dp.filter(filterFn)[0];
				if (selectionPanel) {
					selectionPanel.chartUid = chartUid;
					// N.B.: actual selection detail is fed via `_onSelectionChanged`.
				}
			}
			
			/**
			 * Listener. Executes after user has changed the values of the active chart by
			 * adding, deleting or moving nodes.
			 */
			private function _onNodesChange(event:ChartEditEvent):void {
			
				// Just prints out the new values.
				trace(event.edit);
			}
			
			/**
			 * Listener. Executes after user has caused the selection of the active chart to
			 * change. Updates the `SelectionPanel` instance.
			 */
			private function _onSelectionChanged(event:SelectionEvent):void {
				if (!event || !event.details) {
					return;
				}
			
				const selDetails:SelectionDetails = event.details;
				selectionPanel.dataProvider = selDetails;
				_haveSelection = !!selDetails.selectedValue;
			}
			
			/**
			 * Listener. Executes after user has modified the value of one or more selected nodes
			 * by means of the `SelectionPanel` instance.
			 */
			private function _onSelectionPatch(event:SelectionEvent):void {
				if (!event || !event.details) {
					return;
				}
			
				// N.B.: passing `true` as second argument also dispatches SELECTION_CHANGE
				// and NODES_CHANGE events.
				nodalEditor.patchSelection(event.details, true);
			}
			
			// [STRESS_TESTING]
			private var _numTests:int = 0;
			
			private var _testCharts:Array = [];
			
			/**
			 * Generates a random number in [0,1], inclusive of both ends.
			 */
			private function _randomUnit():Number {
				return Math.round(Math.random() * 10000) / 10000;
			}
			
			/**
			 * Creates and adds a new chart with randomly generated data points to the data provider.
			 *
			 * <p>This function generates a chart with the following characteristics:</p>
			 * <ul>
			 * <li>Random number of data points (0-20)</li>
			 * <li>Each point has random x,y coordinates in the range [0,1]</li>
			 * <li>Points are automatically sorted by x-coordinate</li>
			 * <li>Chart has a random hue factor for coloring</li>
			 * <li>50% chance of having a random dash style</li>
			 * <li>Inserted at a random position in the data provider</li>
			 * </ul>
			 *
			 * <p>If the data provider is null, it will be initialized as an empty Vector.</p>
			 *
			 * @return The index at which the new chart was inserted in the data provider
			 *
			 * @see ChartDescriptor
			 * @see Helpers#makeUuid()
			 */
			private function _addRandomChart():int {
				const $dp:Vector.<ChartDescriptor> = dp? dp.concat() : new <ChartDescriptor>[];
				var count:int = Math.floor(Math.random() * 21); // 0..20
				var values:Vector.<Point> = new <Point>[];
				for (var i:int = 0; i < count; i++) {
					var x:Number = _randomUnit();
					var y:Number = _randomUnit();
					values.push(new Point(x, y));
				}
			
				values.sort(function(a:Point, b:Point):int {
						return a.x < b.x ? -1 : (a.x > b.x ? 1 : 0);
					});
			
				const name:String = "Random Item " + (++_numTests);
				const uid:String = Helpers.makeUuid();
				const hueFactor:Number = _randomUnit();
			
				var dashStyle:Vector.<Number> = null;
			
				if (Math.random() < 0.5) {
					var dash:int = Math.max(1, Math.round(Math.random() * 20));
					var gap:int = Math.max(1, Math.round(Math.random() * 20));
					dashStyle = new <Number>[dash, gap];
				}
			
				var testChart:ChartDescriptor = new ChartDescriptor(uid, values, name, hueFactor, dashStyle);
				_testCharts.push(testChart);
				const index:int = Math.floor(Math.random() * ($dp.length + 1));
				$dp.splice(index, 0, testChart);
			
				dp = $dp;
			
				trace('`_addRandomChart()` called. Added (index, item):', index, testChart);
				return index;
			}
			
			// private function _addEmptyChart():void {
			// if (!dp) {
			// _setEmptyDataProvider();
			// }
			// var index:int = Math.floor(Math.random() * (dp.length + 1));
			// var emptyChart:Object = {
			// name: "Random Item " + (++_numTests),
			// values: []
			// };
			// dp.addItemAt(emptyChart, index);
			// _testCharts.push(emptyChart);
			// }
			
			// private function _addTestChart():void {
			// if (!dp) {
			// return;
			// }
			// const idx:int = _addRandomChart();
			// const testChart:Object = dp.getItemAt(idx);
			// _testCharts.push(testChart);
			// }
			
			// private function _removeLastTestChart():void {
			// if (!dp) {
			// return;
			// }
			// if (!_testCharts.length) {
			// return;
			// }
			// const toRemove:Object = _testCharts.pop();
			// var removed:Boolean;
			// if (toRemove === null) {
			// removed = dp.removeItemAt(dp.getItemIndex(null));
			// }
			// else {
			// removed = dp.removeItem(toRemove);
			// }
			// trace('`_removeRandomItem()` called. Removed: ', removed ? JSON.stringify(toRemove) : 'NULL');
			// }
			
			// private function _setNullDataProvider():void {
			// dp = null;
			// }
			
			private function _setEmptyDataProvider():void {
				dp = new <ChartDescriptor>[];
			}
			
			private function _setNullItem():void {
				if (!dp) {
					_setEmptyDataProvider();
				}
				// var index:int = Math.floor(Math.random() * (dp.length + 1));
				// dp.addItemAt(null, index);
				// _testCharts.push(null);
			}
		]]>
	</fx:Script>

	<s:VGroup padding="25" width="100%" height="100%"
		horizontalAlign="justify">

		<!-- Controls bar -->
		<s:HGroup id="controls">

			<!-- List of available charts. Sets and reflects the active chart. -->
			<s:Group width="100%">
				<s:ComboBox
					id="chartsList"
					dataProvider="{_chartsListDp}"
					change="{_onActiveChartChanged()}"/>
			</s:Group>

			<!-- Selection-related UI -->
			<s:HGroup horizontalAlign="center" width="100%">
				<s:Button label="Clear selection"
					enabled="{_haveSelection}"
					click="{_clearSelection()}"/>

				<s:Button label="Delete selection"
					enabled="{_haveSelection}"
					click="{_deleteSelection()}"/>
			</s:HGroup>

			<!-- Editing mode for current chart -->
			<s:Group width="100%">
				<s:ButtonBar id="modeButtons"
					selectedIndex="1"
					dataProvider="{chartModes}"
					change="_onModeChanged(event)"
					right="0"/>
			</s:Group>

		</s:HGroup>

		<!-- Nodal component (the actual charts editor) -->
		<flexnodal:Nodal
			id="nodalEditor"
			height="100%"
			dataProvider="{dp}"
			gridDataProvider="{gridDp}"
			chartStyle="myChartStyle"
			selectionChange="_onSelectionChanged (event)"
			nodesChange="_onNodesChange (event)"
			chartActivation="_onChartActivated (event)"/>

		<!-- Selection panel, for monitoring and adjusting selected nodes' value -->
		<s:VGroup horizontalAlign="center">
			<components:SelectionPanel
				id="selectionPanel"
				styleName="selectionPanelStyle"
				selectionPatch="_onSelectionPatch (event)"/>
		</s:VGroup>

		<!-- Various buttons for stress-testing -->
		<s:TileGroup horizontalAlign="justify"
			columnAlign="justifyUsingWidth"
			rowAlign="justifyUsingHeight"
			verticalGap="20" horizontalGap="20"
			requestedRowCount="2"
			rowHeight="22">

			<s:Button label="Add test chart" click="_addRandomChart()"/>
			<!--<s:Button label="Add empty chart" click="_addEmptyChart()"/>
			<s:Button label="Remove last test chart" click="_removeLastTestChart()"/>
			<s:Button label="Set NULL data provider" click="_setNullDataProvider()"/>
			<s:Button label="Set NULL item" click="_setNullItem()"/>
			<s:Button label="Set empty data provider" click="_setEmptyDataProvider()"/> -->
		</s:TileGroup>

	</s:VGroup>
</s:WindowedApplication>
